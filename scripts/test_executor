#!/usr/bin/env python2

import rospy
import math
import tf2_ros
import PyKDL
import copy

import geometry_msgs.msg
from omnivelma_driver.srv import STPT
from moveit_msgs.msg import AttachedCollisionObject, CollisionObject
from shape_msgs.msg import SolidPrimitive

from velma_common import *
from rcprg_planner import *
from rcprg_ros_utils import exitError


class SetpointGenerator():
	def __init__(self):
		self.tfBuffer = tf2_ros.Buffer()
		self.tfListener = tf2_ros.TransformListener(self.tfBuffer)

	def generate(self, destinationFrame, safetyTranslation):
		rospy.sleep(0.5)
		msg = self.tfBuffer.lookup_transform("map", destinationFrame, rospy.Time(0))
		rot = msg.transform.rotation
		setpointRot = PyKDL.Rotation.Quaternion(rot.x, rot.y, rot.z, rot.w)
		trans = msg.transform.translation
		destinationFrame = PyKDL.Frame(setpointRot, PyKDL.Vector(trans.x, trans.y, trans.z))
		setpointVector = destinationFrame * safetyTranslation
		setpointRot.DoRotZ(math.pi)
		result = (setpointVector.x(), setpointVector.y(), setpointRot.GetRPY()[2])
		print(result)
		return result


class VelmaTaskExecutor():
	def __init__(self):
		self.velma = VelmaInterface()
		if not self.velma.waitForInit(timeout_s=10.0):
			raise Exception("Could not initialize VelmaInterface")

		if self.velma.enableMotors() != 0:
			raise Exception("Could not enable motors")

		self.velma.startHomingHP()
		if self.velma.waitForHP() != 0:
			raise Exception("Could not home head pan motor")

		self.velma.startHomingHT()
		if self.velma.waitForHT() != 0:
			raise Exception("Could not home head tilt motor")

		diag = self.velma.getCoreCsDiag()
		if not diag.motorsReady():
			raise Exception("Motors must be homed and ready to use for this test.")		

		self.omniplannerServiceName = "/omniplanner/go_to_stpt"
		self.omniplannerService = rospy.ServiceProxy(self.omniplannerServiceName, STPT)

		self.octomapListener = 

		self.acquiringJointState = {
			'torso_0_joint': 0, 
	        'right_arm_0_joint': 0.2176005457580103,   
	        'left_arm_0_joint': 0.2345004080527655,
	        'right_arm_1_joint': -1.9107791904878497,  
	        'left_arm_1_joint': 1.8034769374904756,
	        'right_arm_2_joint': 1.2409542924753767,   
	        'left_arm_2_joint': -1.1982341925787994,
	        'right_arm_3_joint': 1.4842204142092719,   
	        'left_arm_3_joint': -0.8278483633253793, 
	        'right_arm_4_joint': 0.2525831592128146,   
	        'left_arm_4_joint': 0.07257063733648089,
	        'right_arm_5_joint': -1.5390250000127208,  
	        'left_arm_5_joint': 0.4699180006050142,
	        'right_arm_6_joint': -0.21426825617036566, 
	        'left_arm_6_joint': -0.0703725749418421,            
    	}

	def setJointImpedanceMode(self):
		self.velma.moveJointImpToCurrentPos(start_time=0.2)
		error = self.velma.waitForJoint()
		if error != 0:
			raise Exception("The action should have ended without error, but the error code is {}".format(error))

		rospy.sleep(0.5)
		diag = self.velma.getCoreCsDiag()
		if not diag.inStateJntImp():
			raise Exception("Core CS should be in joint impedance mode but it is not")

	def setCartesianImpedanceMode(self):
		if not self.velma.moveCartImpRightCurrentPos(start_time=0.2):
			raise Exception("Could not set CartImp mode for right lwr")

		if self.velma.waitForEffectorRight() != 0:
			raise Exception("Right effector error")

		if not self.velma.moveCartImpLeftCurrentPos(start_time=0.2):
			raise Exception("Could not set CartImp mode for left lwr")

		if self.velma.waitForEffectorLeft() != 0:
			raise Exception("Left effector error")

		rospy.sleep(0.5)
		diag = self.velma.getCoreCsDiag()
		if not diag.inStateCartImp():
			raise Exception("Core CS should be in cartesian impedance mode but it is not")

	def moveBodyToStartingPosition(self):
		startingJointState = {
			'torso_0_joint':0,
        	'right_arm_0_joint':-0.3,   
        	'left_arm_0_joint':0.3,
        	'right_arm_1_joint':-1.8,   
        	'left_arm_1_joint':1.8,
        	'right_arm_2_joint':1.25,   
        	'left_arm_2_joint':-1.25,
        	'right_arm_3_joint':0.85,   
        	'left_arm_3_joint':-0.85,
        	'right_arm_4_joint':0,      
        	'left_arm_4_joint':0,
        	'right_arm_5_joint':-0.5,   
        	'left_arm_5_joint':0.5,
        	'right_arm_6_joint':0,      
        	'left_arm_6_joint':0
        }
		self.velma.moveJoint(startingJointState, 3.0, start_time=0.5, position_tol=10.0/180.0*math.pi)
		if self.velma.waitForJoint() != 0:
			raise Exception("Moving body failed")

	def moveHeadToStartingPosition(self):
		startingHeadState = (0, 0)
		self.velma.moveHead(startingHeadState, 3.0, start_time=0.5)
		if self.velma.waitForHead() != 0:
			raise Exception("Moving head failed")
		rospy.sleep(0.5)

		if not isHeadConfigurationClose(self.velma.getHeadCurrentConfiguration(), startingHeadState, 0.1):
			raise Exception("Head too far from destination")

	def moveToStartingPosition(self):
		self.setJointImpedanceMode()
		self.moveBodyToStartingPosition()
		self.moveHeadToStartingPosition()

	def hideHands(self):
		handDesiredState = [0.5*math.pi, 0.5*math.pi, 0.5*math.pi, math.pi]

		self.velma.moveHandRight(handDesiredState, [1, 1, 1, 1], [2000, 2000, 2000, 2000], 1000, hold=True)
		self.velma.moveHandLeft(handDesiredState, [1, 1, 1, 1], [2000, 2000, 2000, 2000], 1000, hold=True)
		if self.velma.waitForHandRight() != 0 and self.velma.waitForHandLeft() != 0:
			raise Exception("Could not hide hands")

	def driveToPointOnMap(self, setpoint):
		(x, y, yaw) = setpoint
		setpoint = STPT
		setpoint.x = x
		setpoint.y = y
		setpoint.theta = yaw
		setpoint.linear_velocity = 0.0
		setpoint.angular_velocity = 0.0

		response = self.omniplannerService(setpoint)
	
	def prepareForGrip(self, destinationFrame):
		T_Wo_Cabinet = self.velma.getTf("Wo", destinationFrame)
		T_B_Cabinet = self.velma.getTf("B", destinationFrame)

		cabinetX = T_Wo_Cabinet.p[0]
		cabinetY = T_Wo_Cabinet.p[1]
		cabinetZ = T_Wo_Cabinet.p[2]

		torsoAngle = math.atan2(cabinetY, cabinetX)
		if torsoAngle > math.pi /2:
			torsoAngle = math.pi /2 - 0.1
		elif torsoAngle < -math.pi /2:
			torsoAngle = -math.pi /2 + 0.1
		else:
			pass

		desiredJointState = copy.deepcopy(self.acquiringJointState)
		desiredJointState["torso_0_joint"] = torsoAngle

		self.velma.moveJoint(desiredJointState, 2.0, start_time=0.5, position_tol=10.0/180.0*math.pi)

		if self.velma.waitForJoint() != 0:
			raise Exception("Could not move joints")

		rospy.sleep(0.5)
		lastJointState = self.velma.getLastJointState()
		if not isConfigurationClose(desiredJointState, lastJointState[1]):
			raise Exception("Could not acquire desired joint state")

		self.setCartesianImpedanceMode()
		return T_B_Cabinet

	def resolveRelativePosition(self, tf, deltaX, deltaY, deltaZ):
		(rotX, rotY, rotZ) = tf.M.GetRPY()
		posX = tf.p.x() + math.cos(rotZ)*deltaX - math.sin(rotZ)*deltaY
		posY = tf.p.y() + math.sin(rotZ)*deltaX + math.cos(rotZ)*deltaY
		posZ = tf.p.z() + deltaZ
		yaw = rotZ - math.pi
		if yaw < -math.pi:
			yaw += 2*math.pi
		return [posX, posY, posZ, yaw]


	def moveRelativeToInCartImpMode(self, tf, x, y, z, angle, tol=10):
		(setpointX, setpointY, setpointZ, setpointYaw) = self.resolveRelativePosition(tf, x, y, z)
		targetFrame = PyKDL.Frame(PyKDL.Rotation.RPY(0, 0, setpointYaw+angle), PyKDL.Vector(setpointX, setpointY, setpointZ))
		result = self.moveInCartesianImpedanceMode(targetFrame, tol)
		return result

	def moveInCartesianImpedanceMode(self, T_B_dest, tol=10):
		if not self.velma.moveCartImpRight([T_B_dest], [5.0], None, None, None, None, PyKDL.Wrench(PyKDL.Vector(5,5,5), PyKDL.Vector(5,5,5)), start_time=0.1, path_tol=PyKDL.Twist(PyKDL.Vector(tol, tol, tol), PyKDL.Vector(tol, tol, tol))):
			raise Exception("Could not move in cartesian impedance mode")
		if self.velma.waitForEffectorRight() != 0:
			if not self.velma.moveCartImpRightCurrentPos(start_time=0.01):
				raise Exception("Could not make it to given position")
			return False
		else:
			return True

	def setRightLWRImpedance(self, imp_p_x, imp_p_y, imp_p_z, imp_r_x, imp_r_y, imp_r_z):
		if not self.velma.moveCartImpRight(None, None, None, None, [PyKDL.Wrench(PyKDL.Vector(imp_p_x, imp_p_y, imp_p_z), PyKDL.Vector(imp_r_x, imp_r_y, imp_r_z))], [2], PyKDL.Wrench(PyKDL.Vector(5,5,5), PyKDL.Vector(5,5,5)), start_time=0.5):
			raise Exception("Could not change impedance of right lwr")
		if self.velma.waitForEffectorRight() != 0:
			raise Exception("Could not change impedance of right lwr")
		rospy.sleep(1)

	def moveHeadTo(self, headPan, headTilt):
		desiredHeadState = (headPan, headTilt)
		self.velma.moveHead(desiredHeadState, 3.0, start_time=0.5)
		if self.velma.waitForHead() != 0:
			raise Exception("Moving head failed")
		rospy.sleep(0.5)

		if not isHeadConfigurationClose(self.velma.getHeadCurrentConfiguration(), desiredHeadState, 0.1):
			raise Exception("Head too far from destination")

	def lookForObject(self):
		self.moveHeadTo(0.0, 0.7)
		self.moveHeadTo(1.3, 0.7)
		self.moveHeadTo(-1.3, 0.7)
		self.moveHeadTo(0.0, 0.0)

if __name__ == "__main__":
	rospy.init_node('bsc_test_executor')
	rospy.sleep(0.5)
	try:
		setpointGenerator = SetpointGenerator()
		worker = VelmaTaskExecutor()

		print("Moving to position zero")
		worker.moveToStartingPosition()

		print("Hiding both hands")
		worker.hideHands()

		print("Go to first setpoint")
		firstSetpoint = setpointGenerator.generate("cabinet", PyKDL.Vector(0.55, -0.3, 0.0))
		worker.driveToPointOnMap(firstSetpoint)
		rospy.sleep(1.0)

		# OPEN CABINET DOOR
		print("Preparing for grip")
		cabinetTF = worker.prepareForGrip("cabinet")

		print("Moving closer to cabinet")
		worker.moveRelativeToInCartImpMode(cabinetTF, 0.40, -0.1, 0.09, 0.0)

		print("Finding the door")
		worker.setRightLWRImpedance(100, 100, 900, 200, 200, 200)
		worker.moveRelativeToInCartImpMode(cabinetTF, 0.25, -0.1, 0.09, 0.0)

		print("Finding the door handle")
		worker.moveRelativeToInCartImpMode(cabinetTF, 0.30, -0.28, 0.09, 0.0)

		print("Open a lil bit")
		worker.moveRelativeToInCartImpMode(cabinetTF, 0.50, -0.25, 0.09, 0.0)

		print("Open a lil bit more")
		worker.setRightLWRImpedance(300, 300, 900, 200, 200, 200)
		worker.moveRelativeToInCartImpMode(cabinetTF, 0.70, 0.1, 0.09, 0.0)

		print("Moving to starting grabbing position")
		worker.moveToStartingPosition()
		# CATCH CAN
		worker.lookForObject()

		"""
		print("Go to second setpoint")
		secondSetpoint = setpointGenerator.generate("table",PyKDL.Vector(1.0, 0.0, 0.0))
		worker.driveToPointOnMap(secondSetpoint)
		rospy.sleep(1.0)

		# LEAVE CAN ON THE TABLE

		print("Go to starting point")
		thirdSetpoint = (0.0, 0.0, 0.0)
		worker.driveToPointOnMap(thirdSetpoint)
		"""

	except Exception as e:
		print(e)
		exitError(4)

